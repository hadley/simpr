% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/produce_sims.R
\name{produce_sims}
\alias{produce_sims}
\alias{produce_all}
\title{Produce simulated data from specification}
\usage{
produce_sims(obj, reps)

produce_all(obj, reps)
}
\arguments{
\item{obj}{a \code{simpr_spec} object generated
by \code{\link{meta}} or
\code{\link{blueprint}}, containing the
specifications of the simulation}

\item{reps}{number of replications to run (a
whole number greater than 0)}
}
\value{
a \code{simpr_produce} object, which is
  a tibble with a row for each repetition (a
  total of \code{rep} repetitions) for each
  combination of metaparameters and some extra
  metadata used by \code{\link{fit}}.  The
  columns are \code{rep} for the repetition
  number, the names of the metaparameters, and
  a list-column \code{sim_cell} containing the
  dataset for each repetition and metaparameter
  combination.
}
\description{
Use specification from \code{\link{blueprint}}
or \code{\link{meta}} to produce simulated
data.
}
\details{
This is the third step in the simulation
process: after specifying the variables and
metaparameters, \code{produce_sims} is the
workhorse function that actually generates the
simulated datasets, one for each replication,
for each combination of metaparameters. You
likely want to use the output of
\code{produce_sims} to fit model(s) with
\code{\link{fit}}.

Errors you get using this function usually have
to do with how you specified the simulation in
\code{\link{blueprint}} and \code{\link{meta}}.
}
\examples{
meta_list_out = blueprint(x = ~ MASS::mvrnorm(n, rep(0, 2), Sigma = S)) \%>\%
  meta(n = c(10, 20, 30),
       S = list(independent = diag(2), correlated = diag(2) + 2)) \%>\%
  produce_sims(3)

 ## View overall structure of the result
 meta_list_out

 ## View an individual dataset of the resulting simulation
 meta_list_out$sim_cell[[1]]

 ## Changing reps will change the number of replications and thus the number of
 ## rows in the output
 meta_list_2 = blueprint(x = ~ MASS::mvrnorm(n, rep(0, 2), Sigma = S)) \%>\%
  meta(n = c(10, 20, 30),
       S = list(independent = diag(2), correlated = diag(2) + 2)) \%>\%
  produce_sims(4)

 meta_list_2

 ## Fitting, tidying functions can be included in this step by running those functions and then
 ## produce_all.  This can save computation time when doing large
 ## simulations, especially with parallel processing
 meta_list_produce_all = blueprint(x = ~ MASS::mvrnorm(n, rep(0, 2), Sigma = S)) \%>\%
  meta(n = c(10, 20, 30),
       S = list(independent = diag(2), correlated = diag(2) + 2)) \%>\%
  fit(lm = ~ lm(x_2 ~ x_1, data = .)) \%>\%
  tidy_fits \%>\%
  produce_all(4)

  meta_list_produce_all

  ## This is equivalent, but may be slower / more memory-intensive
  meta_list_produce_sims = meta_list_2 \%>\%
  fit(lm = ~ lm(x_2 ~ x_1, data = .)) \%>\%
  tidy_fits


}
\seealso{
\code{\link{blueprint}} and
  \code{\link{meta}} for examples of how these
  functions affect the output of
  \code{produce_sims}
}
