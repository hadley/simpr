% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidy_fits.R
\name{tidy_fits}
\alias{tidy_fits}
\title{Tidy simpr_gen simulated model results output
into tibble of components}
\usage{
tidy_fits(obj, ..., .progress = FALSE, .options = furrr_options())
}
\arguments{
\item{obj}{tibble with repetition number,
metaparameters, simulated data, and fitted
models, from \code{\link[=fit.simpr_tibble]{fit}}}

\item{\dots}{Additional arguments to \code{generics::tidy}.}

\item{.progress}{A logical, for whether or not
to print a progress bar for multiprocess,
multisession, and multicore plans .}

\item{.options}{The \code{future} specific
options to use with the workers when using
futures. This must be the result from a call
to
\code{\link[furrr:furrr_options]{furrr_options()}}.}
}
\value{
a tibble with the output of the
  \code{generics::\link[generics]{tidy}} method
  for the given object.
}
\description{
Turn fitted model of simulated data (from
\code{\link[=fit.simpr_tibble]{fit}}) into a tidy tibble of model
components (via
\code{generics::\link[generics]{tidy}}).
}
\details{
This is part of the fifth step of the
simulation process: after fitting the model
with \code{\link[=fit.simpr_tibble]{fit}}, now tidy the model
output for further analysis such as evaluating
power.  All model objects should be supported
by \code{generics::\link[generics]{tidy}},
primarily via the \code{broom} package.

The output of this function is quite useful for
calculating things such as power for specific
tests within an overall model; see
\emph{Examples}. For looking at overall
features of the model such as R-squared, use
\code{\link{glance_fits}}.
}
\examples{
simple_linear_data = specify(a = ~ 2 + rnorm(n),
          b = ~ 5 + 3 * x1 + rnorm(n, 0, sd = 0.5)) \%>\%
  define(n = 100:101) \%>\%
  generate(2)

## Can show tidy output for multiple competing models,
compare_degree = simple_linear_data \%>\%
  fit(linear = ~lm(a ~ b, data = .),
      quadratic = ~lm(a ~ b + I(b^2), data = .)) \%>\%
  tidy_fits

## Models can be of different types -- anything supported by broom::tidy.
cor_vs_lm = simple_linear_data \%>\%
  fit(linear = ~lm(a ~ b, data = .),
      cor = ~ cor.test(.$a, .$b)) \%>\%
  tidy_fits

cor_vs_lm # has NA for non-matching terms

## Example power analysis to detect an interaction (g1)
\donttest{
set.seed(100)
simpr_tidy = ## Specify the simulation
  specify(a = ~ 2 + rnorm(n),
            b = ~ 3 + 2*a + rnorm(n, 0, sd = 0.5),
            c = ~ 5 + a + b + g1*a*b + 10 * rnorm(n)) \%>\%
  define(n = seq(100, 300, by = 20),
       g1 = seq(-1, 1, by = 0.5)) \%>\%
  ## Generate the data
  generate(10) \%>\%
  ## Fit models
  fit(lm = ~lm(c ~ a*b, data = .)) \%>\%
  ## Calculate the output
  tidy_fits

## Now we can easily calculate and plot power
library(dplyr)
library(ggplot2)
simpr_tidy \%>\%
  filter(term \%in\% "a:b") \%>\%
  group_by(n, g1) \%>\%
  summarize(power = mean(p.value < 0.05)) \%>\%
  ggplot(aes(n, power)) +
  geom_line() +
  facet_grid(~g1)
}
}
\seealso{
\code{\link{glance_fits}} to view
  overall model statistics (e.g. R-squared),
  \code{\link{apply_fits}} to apply an
  arbitrary function to the fits
}
