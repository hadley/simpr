---
title: "simpr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getting-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(simpr)
set.seed(2001)
```

This vignette provides an overview of each step in the `simpr` workflow:

  1. Specify your data-generating process for each of your variables with `specify()`
  2. Define parameters that you want to systematically vary between different cells of your simulation design (e.g. *n*, effect size), with `define()`
  3. Generate the simulation data with `generate()`
  4. Fit models with your data (e.g. `lm()`), with `fit()`
  5. Tidy the model output for further processing, such as computing power or Type I Error rates, with `tidy_fits`
  
## `specify()` your data-generating process

`specify()` takes arbitrary R expressions that can be used for generating data.  **Each argument should have a name and be prefixed with `~`, the tilde operator.**  Order matters: later arguments can refer to earlier arguments, but not the other way around.

Good:
```{r correct_order}
specify(a = ~ runif(6), 
        b = ~ a + rnorm(6)) %>% 
  generate(1)

```

Error:
```{r incorrect_order, warning = TRUE, purl = FALSE}
specify(b = ~ a + rnorm(6),
        a = ~ runif(6)) %>% 
  generate(1)
```

All arguments must imply the same number of rows.  Arguments that imply 1 row are recycled.

OK:
```{r correct_number}
specify(a = ~ runif(6), 
        b = ~ rnorm(6)) %>% 
  generate(1)
```

OK, with recycling:

```{r recycle_number}
specify(a = ~ runif(1), 
        b = ~ rnorm(6)) %>% 
  generate(1)
```

Error:
```{r incorrect_number, warning = TRUE, purl = FALSE}
specify(a = ~ runif(2), 
        b = ~ rnorm(6)) %>% 
  generate(1)
```

Using `x` as an argument to `specify()` is not recommended, because for technical reasons `x` is always placed as the first argument.  This means that if `x` refers to prior variables it will fail:

```{r x_error, warning = TRUE, purl = FALSE}
specify(y = ~ runif(6),
        x = ~ y + runif(6)) %>% 
  generate(1)

```

The same code works fine when `x` is renamed:

```{r x_error_fixed}
specify(y = ~ runif(6),
        a = ~ y + runif(6)) %>% 
  generate(1)
```

### Advanced: expressions that generate multiple columns
`specify()` accepts expressions that generate multiple columns simultaneously in a `matrix`, `data.frame`, or `tibble`.  By default, the column names in the output append a number to the variable name.  Here's an example using `MASS::mvrnorm()`, which produces draws form the multivariate normal distribution:

```{r multicolumn_default}
specify(a = ~ MASS::mvrnorm(6, 
                            mu = rep(0, 3),
                            Sigma = diag(rep(1, 3)))) %>% 
  generate(1)

```

You can change the separator via `.sep`:
```{r multicolumn_sep}
specify(a = ~ MASS::mvrnorm(6, 
                            mu = rep(0, 3),
                            Sigma = diag(rep(1, 3))),
        .sep = ".") %>% 
  generate(1)

```

Alternatively, you can set a two-sided formula to set names; the left hand side must use `c` or `cbind` and the argument name is ignored:

```{r multicolumn_two_sided}
specify(y = c(a, b, c) ~ MASS::mvrnorm(6, 
                            mu = rep(0, 3),
                            Sigma = diag(rep(1, 3)))) %>% 
  generate(1)

```

If your expression already produces column names, those are used by default and the argument name is ignored:

```{r multicolumn_.use_names}
specify(a = ~ MASS::mvrnorm(6, 
                            mu = rep(0, 3),
                            Sigma = diag(rep(1, 3))) %>% 
          magrittr::set_colnames(c("d", "e", "f"))) %>% 
  generate(1)
```

This is useful for dealing with functions from other packages that already provide informative names (e.g., `lavaan::simulateData()`). You can turn this behavior off with `.use_names = FALSE`.

Whatever method you use, you can still refer to these generated variables in later expressions:

```{r multicolumn_refer}
specify(a = ~ MASS::mvrnorm(6, 
                            mu = rep(0, 3),
                            Sigma = diag(rep(1, 3))),
        b = ~ a_1 - a_2) %>% 
  generate(1)
```

## `define()` parameters that you want to systematically vary
`define()` creates metaparameters (also called simulation factors): values that you want to systematically vary.  An obvious choice is sample size:

```{r define_n}
specify(a = ~ rnorm(n)) %>% 
  define(n = c(10, 20)) %>% 
  generate(1)
```

Each argument to `define()` is a vector or list with the desired values to be used in the expressions in `specify().  `specify()` expressions can refer to the names of define arguments, and `generate()` will substitute the possible values that argument when generating data.

When `define()` had multiple arguments, each possible combination is generated:

```{r define_n_mu}
specify(a = ~ rnorm(n, mu)) %>% 
  define(n = c(10, 20),
         mu = c(0, 10)) %>% 
  generate(1)
```

(If not all combinations are desired, see options for filtering at the `generate()` step, below.)

`define()` can also take lists for any type of value used in `specify`. For instance, matrices:

```{r define_matrix}

specify(a = ~ MASS::mvrnorm(6, rep(0, 2), Sigma = s)) %>% 
  define(s = list(independent = diag(rep(1, 2)),
                  dependent = matrix(c(1, 0.5, 0.5, 1), nrow = 2))) %>% 
  generate(1)

```

Note that `simpr` creates a column `s_index` using the names of the list elements of `s` to make the results easier to view and filter.

Functions can also be provided in `define()`:

```{r define_function}
specify(y = ~ distribution(6)) %>%
  define(distribution = list(normal = rnorm,
                             lognormal = rlnorm)) %>%
  generate(1)
```

## `generate()` the simulation data
The main argument to `generate()` is `reps`,  the number of repetitions for each combination of metaparameters in `define()`.

```{r generate_n_mu_2}
specify(a = ~ rnorm(n, mu)) %>% 
  define(n = c(6, 12),
         mu = c(0, 10)) %>% 
  generate(2)
```

Since there are 4 possible combinations of `n` and `mu`, there are a total of 4 * 2 = 8 simulations generated, 2 for each possible combination.

If some combination of variables is not desired, add filtering criteria to `generate()` using the same syntax as `dplyr::filter()`.

```{r generate_filter}
specify(a = ~ rnorm(n, mu)) %>% 
  define(n = c(6, 12),
         mu = c(0, 10)) %>% 
  generate(2, n > mu)
```

To preserve reproducibility, a given simulation in the filtered version of `generate` is still the same as if all possible combinations were generated: note .sim_id skips 3 and 7 above.  See `vignette("reproducibility")` for more information.

`generate()` by default continues with the next iteration if an error is produced, and returns a column `.sim_error` with the text of the error.  Alternative error handling mechanisms are available, see `vignette("simulation-errors")`.

## `fit()` models with your data

`fit()` uses similar syntax to `generate()`: you can write arbitrary R expressions to fit models. **Again, each argument should have a name and be prefixed with `~`, the tilde operator.**

```{r fit_initial}
specify(a = ~ rnorm(6),
        b = ~ a + rnorm(6)) %>% 
  generate(1) %>% 
  fit(t_test = ~ t.test(a, b),
      lm = ~ lm(b ~ a))
```

`fit()` adds columns to the overall tibble to contain each type of fit. Printing the object displays a preview of the first fit object in each column.

Although the function is named `fit`, any arbitrary R expression can be used.

```{r fit_describe}
specify(a = ~ rnorm(6)) %>% 
  generate(1) %>% 
  fit(mean = ~ mean(a),
      why_not = ~ a + 5)


```

`fit()` is computed within each simulation, so usually you do not need to refer to the entire dataset.  If it is needed by your R function, you can refer to the entire dataset using `.`. The below code is equivalent to the previous example, but explicitly referencing the dataset:

```{r fit_explicit}
specify(a = ~ rnorm(6),
        b = ~ a + rnorm(6)) %>% 
  generate(1) %>% 
  fit(t_test = ~ t.test(.$a, .$b),
      lm = ~ lm(b ~ a, data = .))
```

### Advanced: pre-fit data munging with `per_sim()

Sometimes, it's convenient to specify a data-generating process in a different way than R expects it for fitting.  After `generate()`, run `per_sim()` and then chain any `dplyr` or `tidyr` verbs that work on `data.frame`s or `tibble`s.  These verbs will be applied to every individual simulation.

A common use-case is needing to reshape wide to long.  Consider an intervention study with a control group, an intervention group that does slightly better than the control, and a second intervention group that does much better.  This is easiest to specify in wide format, with separate variables for each group:

```{r fit_reshape_1}
wide_gen = specify(control = ~ rnorm(6, mean = 0),
        intervention_1 = ~ rnorm(6, mean = 0.2),
        intervention_2 = ~ rnorm(6, mean = 2)) %>% 
  generate(2) 

wide_gen
```

But to run an ANOVA, we need the outcome in one column and the group name in another column. `per_sim()` and `tidyr::pivot_longer()` make this relatively easy:

```{r fit_reshape_success}
long_gen = wide_gen %>%  
  per_sim() %>% 
  pivot_longer(cols = everything(),
               names_to = "group", 
               values_to = "response")

long_gen
```

Each simulation is now reshaped and ready for fitting:

```{r long_fit}
long_fit = long_gen %>% 
  fit(aov = ~ aov(response ~ group),
      lm = ~ lm(response ~ group))

long_fit
```

## `tidy_fits()` for further processing
The output of `fit()` is not yet amenable to plotting or analysis.  `tidy_fits()` applies `broom::tidy()` to each fit object and binds them together in a single `tibble`:

```{r tidy_fits_simple}
specify(a = ~ rnorm(n),
        b = ~ a + rnorm(n)) %>% 
  define(n = c(6, 12)) %>% 
  generate(2) %>% 
  fit(lm = ~ lm(b ~ a)) %>% 
  tidy_fits()

```

All the same metaparameter information appears in the left-hand column, and all the model information from `broom::tidy()` is provided. This is a convenient format for filtering, plotting, and calculating diagnostics.

If more than one fit is present, `tidy_fits()` simply brings them together in the same `tibble` using `bind_rows`; this means there may be many NA values where one type of model has no values:

```{r tidy_fits_complex}
specify(a = ~ rnorm(n),
        b = ~ a + rnorm(n)) %>% 
  define(n = c(6, 12)) %>% 
  generate(2) %>% 
  fit(lm = ~ lm(b ~ a),
      t_test = ~ t.test(a, b)) %>% 
  tidy_fits()

```

Any option taken by the tidier can be passed through `tidy_fits()`:

```{r tidy_fits_custom}
specify(a = ~ rnorm(n),
        b = ~ a + rnorm(n)) %>% 
  define(n = c(6, 12)) %>% 
  generate(2) %>% 
  fit(lm = ~ lm(b ~ a),
      t_test = ~ t.test(a, b)) %>% 
  tidy_fits(conf.level = 0.99, conf.int = TRUE)

```

`glance_fits()` analagously provides the one-row summary provided by `broom::glance()` for each simulation:

```{r glance_fits_simple}
specify(a = ~ rnorm(n),
        b = ~ a + rnorm(n)) %>% 
  define(n = c(6, 12)) %>% 
  generate(2) %>% 
  fit(lm = ~ lm(b ~ a)) %>% 
  glance_fits()

```

`apply_fits` can take any arbitrary expression (preceded by `~`) or function and apply it to each fit object:

```{r apply_fits}
specify(a = ~ rnorm(n),
        b = ~ a + rnorm(n)) %>% 
  define(n = c(6, 12)) %>% 
  generate(2) %>% 
  fit(lm = ~ lm(b ~ a)) %>% 
  apply_fits(~ summary(.)$r.squared)
```

Similar to `fit()`, the special value `.` indicates the current fit.



